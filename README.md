scanf 缓存造成死循环  
执行scanf.c，输入字符d时，程序会进入死循环，一直打印"Please input again:"：这个代码是从输入流里面获取整型数据，如果输入一个字符型，
scanf是不会将字符数据拿出来，这个数据就一直在缓存里，最后导致了死循环。  
如果这个缓冲区是在栈内分配的，不需要管；但是，如果这个缓冲区是在堆内分配的，就需要手动清除，就像malloc需要和free配合的使用。  
解决办法：  
1、如scanf_1.c中修改，通过getchar()把缓冲值读走，进行缓冲区清理。  
2、在scanf_2.c中对score值初始化为0，再输入字符d进行测试，发现，程序正常；若对score的值初始化为范围之外的值，再输入字符d进行测试，发现程序会进入死循环。
  
查阅一些资料说明：  
在scanf中，从键盘输入的一切数据，不管是数字、字母、还是空格、回车、TAB等字符，都会被当做数据存入缓冲区。存储的顺序是先输入的排在前面，
后输入的依次排在后面，在按回车键的时候，scanf开始进入缓冲区取数据，从前往后依次取。但 scanf 中 %d 只识别“十进制整数”。对 %d 而言，空格、回车、Tab 键都
是区分数据与数据的分隔符。当 scanf 进入缓冲区中取数据的时候，如果 %d 遇到空格、回车、Tab 键，那么它并不取用，而是跳过继续往后取后面的数据，直到取到“十进制整数”
为止。对于被跳过和取出的数据，系统会将它从缓冲区中释放掉。未被跳过或取出的数据，系统会将它一直放在缓冲区中，直到下一个 scanf 来获取。
但是如果 %d 遇到字母，那么它不会跳过也不会取用，而是直接从缓冲区跳出。  
所以在使用scanf函数的时候注意对变量进行正确的处理化，或者进行一些缓冲区清理的保护处理。